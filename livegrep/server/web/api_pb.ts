// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file api.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message Query
 */
export class Query extends Message<Query> {
  /**
   * Which index to search.
   *
   * @generated from field: string index = 1;
   */
  index = "";

  /**
   * Query line.  May include special keywords.
   *
   * @generated from field: string line = 2;
   */
  line = "";

  /**
   * Use regex matching for query text.
   *
   * @generated from field: bool regex = 12;
   */
  regex = false;

  /**
   * Include files (regex).
   *
   * @generated from field: repeated string select_files = 3;
   */
  selectFiles: string[] = [];

  /**
   * Exclude files (regex).
   *
   * @generated from field: repeated string reject_files = 4;
   */
  rejectFiles: string[] = [];

  /**
   * Include repos (regex).
   *
   * @generated from field: repeated string select_repos = 5;
   */
  selectRepos: string[] = [];

  /**
   * Exclude repos (regex)
   *
   * @generated from field: repeated string reject_repos = 6;
   */
  rejectRepos: string[] = [];

  /**
   * Include only these repositories (exact-match).
   *
   * @generated from field: repeated string only_repos = 7;
   */
  onlyRepos: string[] = [];

  /**
   * If set, override automatic case folding.
   *
   * @generated from field: optional bool fold_case = 8;
   */
  foldCase?: boolean;

  /**
   * Max matches to return.
   *
   * @generated from field: int32 max_matches = 9;
   */
  maxMatches = 0;

  /**
   * Only search (and return) filename matches.
   *
   * @generated from field: bool only_filename = 10;
   */
  onlyFilename = false;

  /**
   * Include this many context lines before & after the match.
   *
   * @generated from field: int32 context_lines = 11;
   */
  contextLines = 0;

  constructor(data?: PartialMessage<Query>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Query";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "regex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "select_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "reject_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "select_repos", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "reject_repos", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "only_repos", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "fold_case", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 9, name: "max_matches", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 10, name: "only_filename", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "context_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options);
  }

  static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean {
    return proto3.util.equals(Query, a, b);
  }
}

/**
 * @generated from message SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: Query query = 1;
   */
  query?: Query;

  /**
   * @generated from field: SearchInfo info = 2;
   */
  info?: SearchInfo;

  /**
   * @generated from field: repeated Match matches = 3;
   */
  matches: Match[] = [];

  /**
   * @generated from field: repeated FileMatch file_matches = 4;
   */
  fileMatches: FileMatch[] = [];

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "message", T: Query },
    { no: 2, name: "info", kind: "message", T: SearchInfo },
    { no: 3, name: "matches", kind: "message", T: Match, repeated: true },
    { no: 4, name: "file_matches", kind: "message", T: FileMatch, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * @generated from message SearchInfo
 */
export class SearchInfo extends Message<SearchInfo> {
  /**
   * @generated from field: int64 total_time = 1;
   */
  totalTime = protoInt64.zero;

  /**
   * @generated from field: string exit_reason = 2;
   */
  exitReason = "";

  constructor(data?: PartialMessage<SearchInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "SearchInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "exit_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchInfo {
    return new SearchInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchInfo {
    return new SearchInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchInfo {
    return new SearchInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SearchInfo | PlainMessage<SearchInfo> | undefined, b: SearchInfo | PlainMessage<SearchInfo> | undefined): boolean {
    return proto3.util.equals(SearchInfo, a, b);
  }
}

/**
 * @generated from message Match
 */
export class Match extends Message<Match> {
  /**
   * @generated from field: File file = 1;
   */
  file?: File;

  /**
   * @generated from field: repeated LineMatch lines = 2;
   */
  lines: LineMatch[] = [];

  constructor(data?: PartialMessage<Match>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Match";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
    { no: 2, name: "lines", kind: "message", T: LineMatch, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Match {
    return new Match().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Match {
    return new Match().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Match {
    return new Match().fromJsonString(jsonString, options);
  }

  static equals(a: Match | PlainMessage<Match> | undefined, b: Match | PlainMessage<Match> | undefined): boolean {
    return proto3.util.equals(Match, a, b);
  }
}

/**
 * @generated from message File
 */
export class File extends Message<File> {
  /**
   * @generated from field: string tree = 1;
   */
  tree = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string path = 3;
   */
  path = "";

  constructor(data?: PartialMessage<File>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "File";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tree", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): File {
    return new File().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): File {
    return new File().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): File {
    return new File().fromJsonString(jsonString, options);
  }

  static equals(a: File | PlainMessage<File> | undefined, b: File | PlainMessage<File> | undefined): boolean {
    return proto3.util.equals(File, a, b);
  }
}

/**
 * @generated from message Bounds
 */
export class Bounds extends Message<Bounds> {
  /**
   * @generated from field: uint32 start = 1;
   */
  start = 0;

  /**
   * @generated from field: uint32 end = 2;
   */
  end = 0;

  constructor(data?: PartialMessage<Bounds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Bounds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "end", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bounds {
    return new Bounds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bounds {
    return new Bounds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bounds {
    return new Bounds().fromJsonString(jsonString, options);
  }

  static equals(a: Bounds | PlainMessage<Bounds> | undefined, b: Bounds | PlainMessage<Bounds> | undefined): boolean {
    return proto3.util.equals(Bounds, a, b);
  }
}

/**
 * @generated from message LineMatch
 */
export class LineMatch extends Message<LineMatch> {
  /**
   * @generated from field: int32 line_number = 1;
   */
  lineNumber = 0;

  /**
   * @generated from field: string line = 2;
   */
  line = "";

  /**
   * Match bounds.  Context lines will have none.
   *
   * @generated from field: repeated Bounds bounds = 3;
   */
  bounds: Bounds[] = [];

  constructor(data?: PartialMessage<LineMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "LineMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "line", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "bounds", kind: "message", T: Bounds, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LineMatch {
    return new LineMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LineMatch {
    return new LineMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LineMatch {
    return new LineMatch().fromJsonString(jsonString, options);
  }

  static equals(a: LineMatch | PlainMessage<LineMatch> | undefined, b: LineMatch | PlainMessage<LineMatch> | undefined): boolean {
    return proto3.util.equals(LineMatch, a, b);
  }
}

/**
 * @generated from message FileMatch
 */
export class FileMatch extends Message<FileMatch> {
  /**
   * @generated from field: File file = 1;
   */
  file?: File;

  /**
   * Match bounds within file.path.
   *
   * @generated from field: repeated Bounds bounds = 2;
   */
  bounds: Bounds[] = [];

  constructor(data?: PartialMessage<FileMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "FileMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
    { no: 2, name: "bounds", kind: "message", T: Bounds, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileMatch {
    return new FileMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileMatch {
    return new FileMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileMatch {
    return new FileMatch().fromJsonString(jsonString, options);
  }

  static equals(a: FileMatch | PlainMessage<FileMatch> | undefined, b: FileMatch | PlainMessage<FileMatch> | undefined): boolean {
    return proto3.util.equals(FileMatch, a, b);
  }
}

